<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--
 | Generated by Apache Maven Doxia at Dec 24, 2012
 | Rendered using Apache Maven Fluido Skin 1.2.2
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ehcache File Monitor - Tutorial - Script Caching</title>
    <link rel="stylesheet" href="./css/apache-maven-fluido.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido.min.js"></script>

    
      <meta name="author" content="Steven Swor" />
    <meta name="Date-Creation-yyyymmdd" content="20121220" />
    <meta name="Date-Revision-yyyymmdd" content="20121224" />
    <meta http-equiv="Content-Language" content="en" />
            </head>
        <body class="topBarDisabled">
          
        
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>Ehcache File Monitor</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                  <li id="publishDate">Last Published: 2012-12-24</li>
                      
                
                    
                 <li id="projectVersion" class="pull-right">Version: 1.0-SNAPSHOT</li>
      
                                            <li class="divider pull-right">|</li>
                        
    <li class="pull-right">              <a href="http://commons.apache.org/io/" class="externalLink" target="_blank" title="Commons IO">Commons IO</a>
  </li>

        <li class="divider pull-right">|</li>
      
    <li class="pull-right">              <a href="http://www.ehcache.org/" class="externalLink" target="_blank" title="Ehcache">Ehcache</a>
  </li>

                        </ul>
      </div>

            <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
                
                    
                                    <h3>Tutorial</h3>
                  <ul>
                  <li class="none">
            <strong>Script Caching</strong>
          </li>
                  <li class="none">
                          <a href="performance-tuning.html" title="Performance Tuning">Performance Tuning</a>
            </li>
          </ul>
                        <h3>Project Documentation</h3>
                  <ul>
                                                                                                                                                                                                                                                                                            <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                        <li class="collapsed">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                  </li>
          </ul>
                      
                    
                
          <hr class="divider" />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
        <div id="bodyColumn"  class="span10" >
                                  
            <!--  --><!-- Copyright 2012 Steven Swor. --><!--  --><!-- Licensed under the Apache License, Version 2.0 (the "License"); --><!-- you may not use this file except in compliance with the License. --><!-- You may obtain a copy of the License at --><!--  --><!-- http://www.apache.org/licenses/LICENSE-2.0 --><!--  --><!-- Unless required by applicable law or agreed to in writing, software --><!-- distributed under the License is distributed on an "AS IS" BASIS, --><!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. --><!-- See the License for the specific language governing permissions and --><!-- limitations under the License. --><!--  --><div class="section"><h2>Script Caching Example<a name="Script_Caching_Example"></a></h2><p>This example is based on how script caching is configured in the application for which it was originally developed.</p><div class="section"><h3>Ehcache Configuration<a name="Ehcache_Configuration"></a></h3><p>Ehcache is configured via an <tt>ehcache.xml</tt> in the root of the classpath. In a Jetty deployment environment, this file is located in <tt>$JETTY_HOME/resources</tt>.</p><div class="source"><pre class="prettyprint">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!--
    Don't check for new ehcache versions.
    Limit the cache size to 30% of the JVM's heap size.
--&gt;
&lt;ehcache updateCheck=&quot;false&quot;
         maxBytesLocalHeap=&quot;30%&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:noNamespaceSchemaLocation=&quot;ehcache.xsd&quot;&gt;
    &lt;!--
      Objects expire if they haven't been requested in 10 minutes.
    --&gt;
    &lt;cache name=&quot;GroovyScripts&quot; timeToIdleSeconds=&quot;600&quot;&gt;
        &lt;!--
          Don't persist the cache across JVM restarts.
        --&gt;
        &lt;persistence strategy=&quot;none&quot; /&gt;
    &lt;/cache&gt;
&lt;/ehcache&gt;</pre></div></div><div class="section"><h3>Limiting SizeOf Calculations<a name="Limiting_SizeOf_Calculations"></a></h3><p>In this example, we have limited the size of our cache based on the amount of memory consumed (as opposed to limiting it based on the number of objects in the cache). Ehcache's algorithm for calculating memory usage traverses the object graph for each item in the cache. This can result in a performance penalty if the object graph is very large (Ehcache actually warns you when this happens).</p><p>To limit the scope of the SizeOf algorithm, we can configure ehcache to filter out Groovy's internal classes, since these tend to result in very large object graphs. We put this in a file named <tt>ehcachesizeof.filter</tt> in the root of the class path (i.e. <tt>$JETTY_HOME/resources</tt>):</p><div class="source"><pre class="prettyprint"># This file defines the package, class, and field names which should be ignored
# by Ehcache when it tries to calculate the size of elements in the cache.
#
# Ehcache doesn't like big object graphs because it causes a performance penalty
# when computing the memory footprint for an object.  With this file, we can
# limit how far Ehcache will traverse an object graph when computing the size
# of a cached object.
#
# NOTE: package declarations in this file are not hierarchical.  In other words,
# specifying package foo.bar in this file will ignore class foo.bar.Baz but not
# class foo.bar.xxx.Baz
#
# See http://ehcache.org/documentation/configuration/cache-size

# Ignore Groovy's internal classes
org.codehaus.groovy
groovy.lang</pre></div></div><div class="section"><h3>GroovyObjectFileLoadingCacheEntryFactory<a name="GroovyObjectFileLoadingCacheEntryFactory"></a></h3><p>The <tt>GroovyObjectFileLoadingCacheEntryFactory</tt> is responsible for loading Groovy scripts on the class path and instantiating objects defined in those scripts.</p><div class="source"><pre class="prettyprint">public class GroovyObjectFileLoadingCacheEntryFactory extends FileLoadingCacheEntryFactory {

    @Override
    protected Object loadObjectFromFile(File file) throws Exception {
        Class clazz = loadClassFromFile(file);
        return clazz.newInstance();
    }

    protected Class loadClassFromFile(final File file) throws Exception {
      //...
    }
}</pre></div></div><div class="section"><h3>Application Initialisation<a name="Application_Initialisation"></a></h3><p>Our application has a few tasks which must be performed once, and only once, when it first launches:</p><ul><li><a href="#Configure_Ehcache_SizeOf_Filtering">Configure Ehcache SizeOf Filtering</a></li><li><a href="#Decorate_The_Groovy_Script_Cache">Decorate the Groovy script cache with a <tt>SelfPopulatingCache</tt></a></li><li><a href="#File_Monitoring">Start a timer to monitor the file system</a></li><li><a href="#Register_A_FileMonitoringEventListener">Register a <tt>FileMonitoringCacheEventListener</tt> with the cache</a></li><li><a href="#Eagerly_Evicting_Expired_Items">Start a timer to eagerly evict expired elements from the cache</a></li></ul><div class="section"><h4>Configure Ehcache SizeOf Filtering<a name="Configure_Ehcache_SizeOf_Filtering"></a></h4><p><a href="#Limiting_SizeOf_Calculations">As previously mentioned</a>, we want to limit the scope of Ehcache's SizeOf algorithm with a filtering file. When Ehcache starts up, it looks for the system property <tt>net.sf.ehcache.sizeof.filter</tt>, whose value is the path to the filtering file. We can specify the system property as a JVM argument, or do it programmatically (prior to the first call to <tt>CacheManager.getInstance()</tt>):</p><div class="source"><pre class="prettyprint">/*
 * Set the name of the sizeof filter file.  This will prevent ehcache
 * warnings about object graphs being too large when it tries to
 * calculate the cache size.
 */
System.setProperty(&quot;net.sf.ehcache.sizeof.filter&quot;, &quot;ehcachesizeof.filter&quot;);</pre></div></div><div class="section"><h4>Decorate The Groovy Script Cache<a name="Decorate_The_Groovy_Script_Cache"></a></h4><p>We have a cache defined in <a href="#Ehcache_Configuration">ehcache.xml</a> from which we can obtain object instances loaded from Groovy scripts. However, for all their fancy housekeeping algorithms, caches are merely object repositories. There must be some code, somewhere, which puts stuff into the cache.</p><p>We want to make our caching solution as seamless and transparent as possible. The calling code shouldn't have to take any special action if items are not in the cache (or if the items in the cache are no longer valid).</p><p>Thankfully, Ehcache provides a solution. <tt>SelfPopulatingCache</tt> follows the <a class="externalLink" href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>, wrapping an underlying cache implementation. When items are requested which are not in the cache (or have expired), the wrapper transparently adds a new entry for the item, created by a <tt>CacheEntryFactory</tt>.</p><p>This bit of code decorates the script cache from <tt>ehcache.xml</tt> with a <tt>SelfPopulatingCache</tt> which will load objects using our <a href="#GroovyObjectFileLoadingCacheEntryFactory">GroovyObjectFileLoadingCacheEntryFactory</a>:</p><div class="source"><pre class="prettyprint">/*
 * Replace the groovy script cache defined in ehcache.xml with one that
 * will lazy-load objects from their script files.
 */
CacheManager defaultCacheManager = CacheManager.getInstance();
Ehcache scriptCache = defaultCacheManager.getEhcache(&quot;GroovyScripts&quot;);
SelfPopulatingCache selfPopulatingScriptCache = new SelfPopulatingCache(scriptCache, new GroovyObjectFileLoadingCacheEntryFactory());
defaultCacheManager.replaceCacheWithDecoratedCache(scriptCache, selfPopulatingScriptCache);</pre></div></div><div class="section"><h4>File Monitoring<a name="File_Monitoring"></a></h4><p>Caching scripts reduces disk I/O by only reading from the file system when there isn't a valid entry in the cache. When someone edits the script with updated business logic, we know the new logic should <i>eventually</i> be loaded into the application. The <tt>timeToIdleSeconds</tt> setting in <a href="#Ehcache_Configuration">ehcache.xml</a> ensures that scripts will expire after they have sat in the cache for 10 minutes without being requested. But how can we ensure that the new logic will be loaded if our users are constantly performing tasks which request scripts from the cache?</p><p>To ensure the &quot;freshness&quot; of the business logic in a constant-demand scenario (where a consistent influx of user requests prevents cache entries from expiring), we can use a file monitoring solution which removes an entry from the cache when it detects a change to the associated script file.</p><div class="source"><pre class="prettyprint">/*
 * Start the file monitor, which will detect changes to our scripts.
 *
 * Note: the file monitor is basically just a glorified timer thread.
 * The FileMonitoringCacheEventListener tells it what directories to
 * poll and which files in those directories we are interested in.
 */
fileMonitor = new FileAlterationMonitor(FILE_POLLING_INTERVAL_MILLIS);
fileMonitor.setThreadFactory(new ThreadFactory() {
    @Override
    public Thread newThread(Runnable r) {
        return new Thread(r, &quot;Script Files Monitor&quot;);
    }
});
fileMonitor.start();</pre></div><p>This solution uses <a class="externalLink" href="http://commons.apache.org/io/">Commons IO</a> to monitor the file system, which sets up a dedicated thread to poll the file system at a fixed interval. Alternatively, we could have rolled our own polling solution or used the polling solution provided by <tt>Commons VFS</tt>. If we were willing to constrain the deployment environment's operating system, we could have used a JNI wrapper for <tt>FSEvents</tt> (Mac OS 10.5+), <tt>dnotify</tt> (Linux kernel 2.4+), or <tt>inotify</tt> (Linux kernel 2.6.13+). If we were willing to constrain the deployment environment's JRE, we could have used Java 7's <a class="externalLink" href="http://docs.oracle.com/javase/tutorial/essential/io/notification.html">WatchService</a>.</p></div><div class="section"><h4>Register A FileMonitoringEventListener<a name="Register_A_FileMonitoringEventListener"></a></h4><p>Now that our cache is decorated and the file system monitor is up and running, we can bridge the two together, so that cache entries will be removed when changes are detected to their underlying script files.</p><div class="source"><pre class="prettyprint">/*
 * Add a listener which will automatically remove an object from the
 * cache when its script file changes, and will stop monitoring for
 * script changes when an object is removed, expired, or evicted from
 * the cache.
 */
cacheListener = new FileMonitoringCacheEventListener(selfPopulatingScriptCache, fileMonitor);
selfPopulatingScriptCache.getCacheEventNotificationService().registerListener(cacheListener);</pre></div></div><div class="section"><h4>Eagerly Evicting Expired Items<a name="Eagerly_Evicting_Expired_Items"></a></h4><p>Ehcache lazily checks cache entries for expiration and notifies interested parties (e.g. when application code retrieves items from the cache). This is generally a good idea, since most of the time, it's not a big deal to have a bit of stale data in the cache if nothing can access it. However, our solution uses cache notification to manage file system polling.</p><p>As long as an expired item sits in the cache without the <tt>FileMonitoringCacheEventListener</tt> being made aware of its expiration, we will keep monitoring the file system for changes to that file. This results in unnecessary I/O, since it is guaranteed that, once an item expires, the script will be loaded from the file system the next time it is requested from the cache.</p><p>To reduce the amount of unnecessary I/O, we can periodically ask Ehcache to evict expired items:</p><div class="source"><pre class="prettyprint">/*
 * By default, Ehcache waits until the next &quot;get&quot; call before checking
 * for expiration.  However, as long as a file is in the cache, the file
 * monitor will poll the file system looking for changes to that file, even
 * if the entry has expired (i.e. the next &quot;get&quot; call will cause us to load
 * the script file again).
 *
 * To prevent unnecessary file polling in this case, we start a timer
 * here to periodically ask the cache to evict expired elements.
 */
ehcacheExpirationMonitorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {
   @Override
   public Thread newThread(Runnable r) {
       return new Thread(r, &quot;Ehcache Expiration Monitor&quot;);
   }
});
ehcacheExpirationMonitorService.scheduleWithFixedDelay(new Runnable() {
   @Override
   public void run() {
       Ehcache scriptCache = CacheManager.getInstance().getEhcache(&quot;GroovyScripts&quot;);
       scriptCache.evictExpiredElements();
   }
}, 0, CACHE_EXPIRATION_MINUTES, TimeUnit.MINUTES);</pre></div></div><div class="section"><h4>Putting It All Together<a name="Putting_It_All_Together"></a></h4><p>Here is an example which sets everything up in a single method call.</p><div class="source"><pre class="prettyprint">long FILE_POLLING_INTERVAL_MILLIS = //...
long CACHE_EXPIRATION_MINUTES = //...

/*
 * This method should be called once (and only once), during application
 * start-up.
 */
void startEhCacheOnApplicationLaunch() throws Exception {
   /*
    * Set the name of the sizeof filter file.  This will prevent ehcache
    * warnings about object graphs being too large when it tries to
    * calculate the cache size.
    */
   System.setProperty(&quot;net.sf.ehcache.sizeof.filter&quot;, &quot;ehcachesizeof.filter&quot;);

   /*
    * Replace the groovy script cache defined in ehcache.xml with one that
    * will lazy-load objects from their script files.
    */
   CacheManager defaultCacheManager = CacheManager.getInstance();
   Ehcache scriptCache = defaultCacheManager.getEhcache(&quot;GroovyScripts&quot;);
   SelfPopulatingCache selfPopulatingScriptCache = new SelfPopulatingCache(scriptCache, new GroovyObjectFileLoadingCacheEntryFactory());
   defaultCacheManager.replaceCacheWithDecoratedCache(scriptCache, selfPopulatingScriptCache);

   /*
    * Start the file monitor, which will detect changes to our scripts.
    *
    * Note: the file monitor is basically just a glorified timer thread.
    * The FileMonitoringCacheEventListener tells it what directories to
    * poll and which files in those directories we are interested in.
    */
   fileMonitor = new FileAlterationMonitor(FILE_POLLING_INTERVAL_MILLIS);
   fileMonitor.setThreadFactory(new ThreadFactory() {
       @Override
       public Thread newThread(Runnable r) {
           return new Thread(r, &quot;Script Files Monitor&quot;);
       }
   });
   fileMonitor.start();

   /*
    * Add a listener which will automatically remove an object from the
    * cache when its script file changes, and will stop monitoring for
    * script changes when an object is removed, expired, or evicted from
    * the cache.
    */
   cacheListener = new FileMonitoringCacheEventListener(selfPopulatingScriptCache, fileMonitor);
   selfPopulatingScriptCache.getCacheEventNotificationService().registerListener(cacheListener);

   /*
    * By default, Ehcache waits until the next &quot;get&quot; call before checking
    * for expiration.  However, as long as a file is in the cache, the file
    * monitor will poll the file system looking for changes to that file, even
    * if the entry has expired (i.e. the next &quot;get&quot; call will cause us to load
    * the script file again).
    *
    * To prevent unnecessary file polling in this case, we start a timer
    * here to periodically ask the cache to evict expired elements.
    */
   ehcacheExpirationMonitorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {
       @Override
       public Thread newThread(Runnable r) {
           return new Thread(r, &quot;Ehcache Expiration Monitor&quot;);
       }
   });
   ehcacheExpirationMonitorService.scheduleWithFixedDelay(new Runnable() {
       @Override
       public void run() {
           Ehcache scriptCache = CacheManager.getInstance().getEhcache(&quot;GroovyScripts&quot;);
           scriptCache.evictExpiredElements();
       }
   }, 0, CACHE_EXPIRATION_MINUTES, TimeUnit.MINUTES);
}</pre></div></div></div><div class="section"><h3>Application Shutdown<a name="Application_Shutdown"></a></h3><p>Since caching and file monitoring spawn background threads, we have a bit of housekeeping to do when the application is shut down.</p><div class="source"><pre class="prettyprint">/*
 * This method should be called once (and only once), during application
 * shutdown.
 */
void onApplicationShutdown() {
    /*
     * Stop the cache expiration monitoring timer.
     */
    ehcacheExpirationMonitorService.shutdown();

    /*
     * Stop the file system polling timer.
     */
    try {
        fileMonitor.stop();
    } catch (Exception ex) {
        //trap
    }

    /*
     * Stop Ehcache background threads and allow garbage collection of caches
     * and their contents.
     */
    CacheManager.getInstance().shutdown();
}</pre></div></div></div>
                  </div>
            </div>
      
    <hr/>

    <footer>
            <div class="container-fluid">
              <div class="row span12">Copyright &copy;                   2012.
          All Rights Reserved.      
                    
      </div>

        
        
                </div>
    </footer>
  </body>
</html>
